%Especificacion
\documentclass[12pt]{article}

%Paquetes
\usepackage[left=2cm,right=2cm,top=3cm,bottom=3cm,letterpaper]{geometry}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
%\usepackage[spanish,activeacute]{babel}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{enumerate}
%\usepackage{tabularx}
%\usepackage{wasysym}
\usepackage{graphicx}
%\graphicspath { {tarea01/media/} }
%\usepackage{pifont}

%Preambulo
\title{Complejidad Computacional \\ Tarea 2}
\author{Karla Adriana Esquivel Ramírez \\ Andrea Itzel González Vargas\\ Luis Pablo Mayo Vega \\ Carlos Gerardo Acosta Hernández}
\date{Entrega: 14/03/17 \\ Facultad de Ciencias UNAM}

\setlength\parindent{0pt}

\begin{document}
\maketitle
\section*{Ejercicios}

\subsubsection*{1. Supón que $L_1$, $L_2$ $\in$ $\textbf{NP}$. ¿Qué pasa con $L_1$ $\cup$ $L_2$ y  $L_1$ $\cap$ $L_2$?}

Primero vemos si $L_1$ $\cup$ $L_2$ $\in$ NP: \\
Sea $V_1(x,c)$ un algoritmo verificador para $L_1$ que para una cadena $x$ y un posible certificado $c$, entonces si $V_1(x,c) = 1$ significa que $c$ verifica que $x \in L_1$ y si $V_1(x,c) = 0$ sucede lo contrario. Análogamente $V_2(x,c)$ es un verificador para $L_2$. Ya que $L_1$, $L_2$ $\in$ NP, sabemos que sus respectivos verificadores deben de correr en tiempo polinomial $O(|x|^k)$ para alguna constante k. \\
Sea $L_3 = L_1 \cup L_2$, si podemos construir un verificador $V_3$ para $L_3$ que corra en tiempo polinomial, podremos decir entonces que $L_3 \in NP$. \\
Ya que en $L_3$ estamos uniendo $L_1$ y $L_2$, tenemos que para un certificado $c$ para $L_3$ sucede que $V_1(x,c) = 1$ o $V_2(x,c) = 1$, por lo tanto podemos definir a $V_3$ de la siguiente manera: $V_3(x,c) = V_1(x,c) \or V_2(x,c)$. Para verificar que $V_3$ corre en tiempo polinomial podemos decir que si $V_1$ corre en tiempo $O(|x|^{k_1})$ y $v_2$ en tiempo $O(|x|^{k_1})$, entonces como $V_3$ consiste en correr a $V_1$ y $V_2$, el tiempo en que lo realizara será $O(|x|^{k_1})$ + $O(|x|^{k_2})$ = $O(|x|^{max\{k_1,k_2\}})$, que es tiempo polinomial, y por lo tanto $L_3 \in NP$

\subsubsection*{2.}

\subsubsection*{3.}
\textbf{Demuestra que el lenguaje} \\
\indent \textit{SPACETM} = $\{ \langle$M$\rangle \langle \alpha 
\rangle 1^n$ | M es una MT que acepta $\alpha$ en espacio \textit{n} $\}$ \\
\textbf{es PSPACE-completo.} \\

 P.D.\\


I) $SPACETM \in PSPACE.$\\

II) Cualquier $L \in PSPACE$ se puede reducir a SPACETM\\
 
Entrada < M, $\alpha$, $1^{n}$ >\\

Construimos $M’\in TM$ para Simular M, M’ con dos contadores. \\

I) Un contador para contar el espacio utilizado por M, el otro contador contará el número de pasos que va a ejecutar M. Cada vez después de que M ' Simule un paso de M, actualiza los contadores y comprueba si el espacio utilizado 
es mayor que n o si las etapas que se ejecutan en M son mayores que $2^{cn}$  para alguna constante c que está relacionada con M. 

Si cualquiera de las anteriores ocurre entonces se rechaza inmediatamente.  Observemos que el número total de configuraciones posibles de M es como máximo $2^{cn}$, por lo tanto, si M no se detiene en este número de pasos, entonces debe haber entrado en un bucle infinito y M ' Rechaza, después de simular M corriendo en w, si M acepta w en espacio n, M ' Acepta, en otro caso M’ rechaza.
Por definición de SPACETM, M’ decide a SPACE. Para simular M solamente utilzamos espacio O(n). Entonces SPACETM $\in$ PSPACE\\

II) Ahora Observemos que para cualquier $L \in PSPACE$ dónde L es un lenguaje existe una Maquina de Turing Determinista M que decide L usando espacio s(n) el cual es una entrada polinomial de tamaño n.
Consideremos la función f: $\big \{0,1\}\big \}^{n}$ $\Rightarrow$ $\big \{0,1\}\big \}^{m}$ tal que
$f(x)=< M, x, 1^{s(n)}>.$ Dónde m es polinomial de n. La función f puede ser computada en espacio y tiempo polinomial. Por definición de SPACETM $x\in L$ syss $f(x)\in SPACETM.$ Así que SPACETM es PSPACE-hard entonces $SPACETM \in PSPACE-completo$ \\


$\therefore$ $ Es PSPACE-Completo.$\\



$\dots$

\subsubsection*{4.}
\textbf{Demuestra $2SAT \in NL$ } \\


Primero veamos que para todo F en 2-SAT podemos construir una grafica dirigida G de la siguiente manera:

	V(G) son las literales de F y hay una arista de a a b en E(G) si y solo si (a’ v b ) esta e F 

Con esta construccion veamos que:

	 F es satisfaceible si y solo si G no tiene un ciclo donde exista una literal y su negacion.

=>)

veamos que a’ V b es equivalente a a->b

Supongamos que tenemos un ciclo que contiene a b y b’ en G. 
Si esto pasa entonces por transitividad signfica que b$\rightarrow$...$\rightarrow$b’ y que b’$\rightarrow$…$\rightarrow$b por lo que tendriamos  b $\leftrightarrow$ b’ lo cual es una contradiccion.

Por lo que si F es satisfacible entonces G no tiene un ciclo donde exista una literal y su negacion.

<=)

Veamos estos haciend induccion sobre el numero de variables 
Cuando se tienen 0 varaibles

Si F no tiene variables entonces F es satisfacible y G no tiene ciclos.

Hip. Ind

Supongamos que se cumple cuando se tiene n variables

Ahora vemos que pasa cuadno se tiene un variables mas:

Tomamos una literal b que en la grafica G generada no tiene un camino de b a b’.

Ahora supongamos que hay un camino de b a c y un camino de b a c’

Por contraposicion tendriamos un camino de c’ a b’ y por transitividad tendiamos un camino  b a b’ lo cual sera una contradiccion.

Ahora hagamos todas las literales  a las que llegamos a partir de b verdaderas, esta conjunto esta bien definido por lo anterior visto. Entonces todas las clausulas que contenga a un literal de este conjunto se satisfacen. Y nos queda una grafica G’ dada por las clausulas restantes las cuales tampoco tienen un ciclo con una literal y su negacion y por Hipotesis de induccion esta formula tambien es satisfacible.

.: Si G no tiene ciclos donde existe una literal y su negacion F es satisfacible




En libro tenemos que NL= coNL veamos que 2-SAT’ en NL implica 2-SAT en NL

Para ver si algo cumple con 2-SAT’ basta con ver si hay una camino de alguna literal b a b’ y de b’ a b esto es que exista un ciclo en la grafica G generada. Por lo que podemos reducir el problema a PATH que de igual manera por lo visto en el libro PATH esta en NL.

.: 2-SAT’ esta en NL 
.: 2-SAT esta en NL

\subsubsection*{5.}

\subsubsection*{6.}

\newpage
\section*{Anexo}

\subsubsection*{Tarea 1.1 Ejercicio 1. En clase se presentó una descripción general de cómo codificar una máquina de Turing como una cadena binaria. Completa la descripción de tal forma que una máquina universal pueda utilizarla para imitar la máquina codificada}

Comencemos con la codificación de la máquina de Turing como una cadena binaria.

Sea $M = (Q,\Sigma,\Gamma,\delta,s,r,t,\vdash,\sqcup)$ una máquina de Turing, con
\begin{itemize}
\item $Q = i$
\item $\Sigma = j$
\item $\Gamma = k$
\item $s$ el m-ésimo estado
\item $t$ el n-ésimo estado
\item $r$ el p-ésimo estado
\item $\vdash$ el q-ésimo caracter de $\Sigma$
\item $\vdash$ el r-ésimo caracter de $\Sigma$ 
\end{itemize}
Dicha especificación será codificada por la siguiente cadena binaria:\\
\begin{equation}
  0^i10^j10^k10^m10^n10^p10^q10^r1.
\end{equation}

Continuamos con la codificación de una transición en delta de la forma $\delta(s_u,a_v) = (s_w,a_x,\rightarrow)$ como (2),
mientras que una transición de la forma $\delta(s_u,a_v) = (s_w,a_x,\leftarrow)$ como (3):\\
\begin{equation}
  0^u10^v10^w10^x101
\end{equation}
\begin{equation}
  0^u10^v10^w10^x111  
\end{equation}
De esta manera, podemos codificar completamente la tabla original de M.\\
Finalmente, una cadena de entrada en $\Gamma^*$ de la forma $a_{n_1} \dots a_{n_z}$, quedará codificada por la cadena binaria:\\
\begin{equation}
0^{n_1}10^{n_2}1\dots0^{n_z}
\end{equation}

Recordemos que la Máquina Universal de Turing $U$ que simulará a $M$, consta de tres cintas, además de la de entrada y salida. La primera de ellas
será utilizada para la descripción de $M$, es decir, la tabla que quedó codificada para cada transición $\delta$ como en (3); la segunda, contendrá lo que corresponde con la cinta original de $M$; y la tercera el estado en el que la $M$ se encontraría.

Al iniciar $U$, en la primera cinta ya debe tener la tabla de $M$ codificada, mientras que en la tercera cinta aparecerá un 0, indicando que se encuentra en el estado inicial de la máquina original.

Separados por unos, podemos considerar una cadena binaria proveniente de una codificación de transición en $\delta$, como una quinteta, por los 5 elementos en total que componen una transición. Para emular a $M$, la Máquina Universal de Turing $U$, deberá hacer lo siguiente por cada
transición de la TM original:\\
\begin{enumerate}
\item Localiza en la primera cinta aquella quinteta en la que el primer componente sea igual al que se encuentra en la tercera cinta y el segundo
  componente sea igual al que se encuentra en la segunda cinta.
\item Copia a la tercera cinta el tercer componente de la primera cinta (el estado al que se transfiere).
\item Sustituye la segunda cinta con lo que tiene el cuarto componente.
\item Interpetra el movimiento de la cabeza que se encuentra en el quinto componente, moviendo acorde la cabeza de la segunda cinta. 
\end{enumerate}

\end{document}